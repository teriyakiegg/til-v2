# overview of Go

https://www.amazon.co.jp/%E3%82%B9%E3%82%BF%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0Go%E8%A8%80%E8%AA%9E-%E6%9D%BE%E5%B0%BE%E6%84%9B%E8%B3%80-ebook/dp/B01FH3KRTI/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=&sr=

『スターティングGo言語』この本より

- オブジェクト志向機能を持たない
- 例外機構を持たない
- シンプルさと合理性を追求した言語
- 2009年に発表された、Googleによって開発された言語
- ここ↓で今もオープンソース形式で開発行われてる  
https://github.com/golang/go
- コンパイル型言語で、各CPUとOSに適合したネイティブコードを生成するので、実行環境は不要。そしてマルチプラットフォームで動作。
- ガベージコレクターがあって、メモリリークとかは防いでくれる
- 並行処理はゴルーチンなるものがある
- スクリプト言語より実行性能は高い

- 拡張子は.go
- go run ファイル名.go でビルドプロセスを隠蔽しつつ直接プラグラムを実行できる
- 変数や関数等のプログラムの全ての要素は何らかのpackageに属する。そのため、プラグラムはpackageの宣言から始まる。
- 一つのファイルに記述できるのは単一のpackageのみ。一つのファイルに複数のpackage宣言があるとコンパイルエラー
- 参照されてないのにimportしてる不要なパッケージがあるとコンパイルエラーになる
- エントリーポイントはmainパッケージのmain関数。

- go build -o 出力実行ファイル名 ファイル名.go でビルドして実行ファイルを作ることも可能。オプション無しでgo buildしたらカレントディレクトリの名前を実行ファイルの名前に転用する。対象ファイルも勝手に.goファイルをビルド対象として読み込む
- GoはOSによって提供される標準的なライブリらりに依存しないため、実行ファイルには諸々のパッケージなど詰め込まれるので、ファイルサイズが大きくなる
- 同ディレクトリで同パッケージで別ファイルの関数呼び出しは、go runする時呼び出し元だけでなく呼び出し先のファイル名も一緒に指定しないとエラーになる。もしくは*.go指定。go buildだと勝手に*.go指定になるが、ファイル名を明示してしまうとgo runと同じ挙動になる。
- 1つのディレクトリには1つのパッケージ定義のみ、の原則
- Goはファイル名が _test.go で終わってるファイルを、パッケージをテストするためのファイルとして特別扱いする
- go testでテスト実行できる。-v で詳細ログ表示
- 行末のセミコロンは全て省略できる。コンパイラがよしなに挿入してくれる。ただ、配列の要素の羅列の際は最後の要素にもカンマを入れないとコンパイルエラーになったりするようなので注意。

- 未使用変数があるとコンパイルエラーになる。素敵
- 暗黙的な型変換を一切許容しない。明示的なキャストはできる。こんなん↓
```
var i int = 100
var f float64 = float64(i)
```

- 並列処理が得意の模様
- Go、高速なAPIサーバーのために使われたりする。あとはマイクロサービス
- 学習コストはだいぶ低いと見られてる模様
- 文字列の改行はバッククォート（`）文字で挟めばOK
- interface{}型は万能マン
- 関数は型として扱える。無名関数も使える
- クロージャ内のローカル変数の扱い面白い
- 型アサーションとinterface{}面白い。reflect.TypeOf(value)でvalueの型が分かる
- ラベルで多重階層脱出可能
- deferは後入れ先出し。複数処理したい時は無名関数でまとめる
- init関数面白い
- slice, map, channelは参照型。関数の引数に渡したりする時は値渡しではなく参照渡しになる。未初期化時の初期値、配列だとその型のデフォ値だが、sliceはnilになる
- switchも簡易文書ける。break書かなくてもcase文毎に止まる(フォールスルーしない)必要ならfallthroughを明示的に書く
- 存在しないキーでmapを参照してもぬるぽにならない。型毎の初期値が入ってる。参照型はnil。
- チャネル、ゴルーチン一つで受信だけしてるとデッドロックになる。チャネルはゴルーチン間でのデータの送受信の役割。宣言時のバッファサイズ超えたら使えなくなる。closeした後は送信は不可。受診はcloseしてもバッファ内にあるやつは受信し続ける。バッファ内になくなって受信してもエラー起きない
- ポインターは参照型同様、初期値はnil
- goの文字列型は、ポインタ操作の煩雑さを内部的に隠蔽しつつ「不変」という性質を保っている、少々特殊な存在

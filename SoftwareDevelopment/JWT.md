# JWT
## JSON Web Token の効用
https://qiita.com/kaiinui/items/21ec7cc8a1130a1a103a

## JWTの仕様
```
token = encode_base64url(header) + "." + encode_base64url(payload) + "." + encode_base64url(signature)

header = JWTの署名アルゴリズム等に関するメタデータが入ったJSON文字列

payload = 任意のデータが含められるJSON文字列

signature = 署名 = sign(signingKey, encode_base64url(header) + "." + encode_base64url(payload))
sign = 署名に使うアルゴリズム（headerにて指定されている）
```
https://qiita.com/take4s5i/items/009b0b6797b752921a78

headerとpayloadはBase64urlエンコードした文字列なので、デコードが容易にできる

## デメリット
```
JWTのデメリットはリアルタイムでユーザー無効化ができないこと
https://auth0.hatenablog.com/entry/2018/09/21/004131
```
理由は、DBにユーザーIDやアクセストークン自体を保存せず、アクセストークンは有効期限が切れるまでは有効だから。  
そのためトークンの有効期限は短く設定する模様

## セキュリティ注意点
### algの改ざん
https://www.wakuwakubank.com/posts/523-it-jwt/  
https://techblog.yahoo.co.jp/advent-calendar-2017/jwt/
```
対策
利用可能な alg をホワイトリスト形式で制限するなどの対応が必要です。

e.g.) RS256 のみ取り扱うように実装する。
```

## 実運用エピソード
### JWT形式を採用したChatWorkのアクセストークンについて
https://creators-note.chatwork.com/entry/2018/09/25/132218
```
トークンは大別すると、以下の形式があります。

Artifact
トークンにはメタデータを保持せずIDのみ。メタデータはサーバ側のストレージに持つことが一般的

Assertion
メタデータをすべて内包する形式。JWTはその代表格。
```
```
ChatWorkでは、なぜJWT形式を選んだか？その理由は以下です

1. サーバ側でメタデータを管理するストレージの運用コスト削減のため
2. マイクロサービスが増えた場合に、リソースサーバ単体での認可を実装しやすい
今のところ、大きな理由は1番ですね。
```
```
アクセストークンの失効管理
Assertion形式のJWTの場合はサーバに状態がないので、トークンの失効が即時にできません。なので、できるだけ有効期間を短くした方がよいです。また、漏れたアクセストークンは有効期間の間は失効できません。そのアクセストークンの生存期間中の二次被害を防止するには、認可サーバでの当該認可の破棄、リソースサーバでの利用権限の一次停止などの別の仕組みを検討する必要があるでしょう。

しかし、サーバに状態があるArtifact形式だからといって、即座に失効できるとは限らないと考えます。当該認可の破棄、漏洩したトークンの確認、API権限の一時停止、分散キャッシュ上からトークンIDを特定・削除の実行などのワークフローを社内で実行するには30分ぐらいは掛かると考えました。

ChatWorkのアクセストークンも期限が30分と比較的短い時間に設定しています。仮に、アクセストークンが漏洩した場合は、当該認可の破棄、対象のユーザのAPI機能を一次停止するなどの対応を取るものの、漏洩したトークンが利用できなくなるまで(30分間)待つことになります。もちろん、漏洩した根本原因に対しては恒久対策すべきですが、応急対策としてはこのようになると想定しています。というわけで、我々は、Assertionでも実運用に耐えられると判断し、JWT形式のアクセストークンを選択しました。

Assertion形式を採用する場合は、この運用ポリシーを許容できなければなりません。まず設計の最初でこれを確認しておきましょう*4。
```
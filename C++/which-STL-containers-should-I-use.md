# Which STL containers should I use
- 連想配列は基本ハッシュテーブル(Hash map)のunordered_map
- 連想配列にてキーでのソートを保持したいなら平衡二分探索木(Tree map)のmap
- 要素数が固定の配列ならarray
- 要素数が固定でなく、要素数少なかったらとりあえずvector  
- 配列に指定の要素が存在するかの検索メインの配列ならunordered_set、ソートされてて欲しかったらset 　 
https://qiita.com/h_hiro_/items/a83a8fd2391d4a3f0e1c  

だいぶ分かりやすいスライド  
https://www.slideshare.net/mobile/maraigue/stl-overview  

vectorは連続したメモリ領域に要素を格納。  
連続してるためランダムアクセスはO(1)。(生配列と同じ)  
要素の挿入、削除は大体O(n)。  
途中に挿入、削除すると、後ろの要素を全てずらす必要があるため。  
末尾の削除についてはO(1)。ずらす必要がないため。  
末尾の挿入についてはメモリ領域足りなくなったら配列丸ごと別のメモリ領域に引っ越す必要あるためO(n)  
ただ、メモリ領域の確保は常にギリギリではないため、引っ越す必要が無ければO(1)  
要素を格納するメモリ領域とメモリ領域の起点、領域のサイズのみ使うのでメモリ消費量は少ない  
要素の検索はO(n)  

listは要素毎に次と前の要素のポインタ変数が必要な双方向連結配列  
一方向連結で良いならforward_listがある。もちろんこっちの方がメモリ消費量は少ない  
vectorと違って要素が連続していないので、ランダムアクセスはO(n)  
その分、挿入と削除がO(1)。前後のポインタを入れ替えるだけで良いため  
要素の検索はvector同様O(n)  

vectorは要素の挿入、削除、検索にO(n)がかかるが、  
要素数が少ないのであればこの計算量も問題にならないはずで、  
メモリの消費量が少ないことによる恩恵がでかいはず、  
ということから、要素数が少ないならとりあえずvectorという結論が導かれてる模様  
